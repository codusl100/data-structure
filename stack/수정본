import java.util.Scanner;
import java.io.InputStreamReader;
import java.util.EmptyStackException;
class Stack<E>{
	private E s[]; // 스택을 위한 배열
	private int top; // 스택의 top 항목의 배열 원소 인덱스
	private int size; // 스택의 사이즈
	public Stack() { // 스택 생성자
		s = (E[]) new Object[1]; //초기에 크기가 1인 배열 생성
		top = -1;
		size = 0;
	}
	public int size() {return top+1;} //스택에 있는 항목의 수를 리턴
	public boolean isEmpty() {return (top == -1);}	//스택이 empty이면 true 리턴
	//peak(), push(), pop(), resize() 메소드 선언


public E peek() { //스택 top 항목만의 내용만을 리턴
	if (isEmpty()) throw new EmptyStackException(); //underflow시 프로그램 정지
	return s[top];
}	

public void push(E newItem) { // push 연산
	if(size() == s.length)
		resize(2*s.length); //스택을 2배의 크기로 확장
	s[++top] = newItem; //새 항목을 push
}

public E pop() { // pop 연산
	if(isEmpty()) throw new EmptyStackException(); //underflow시 프로그램 정지
	E item = s[top];
	s[top--] = null; //null로 초기화
	if(size()>0 && size()==s.length/4)
		resize(s.length/2); //스택을 1/2 크기로 축소
	return item;
}

public void resize(int length) { //다시
	  E b[] = (E[]) new Object[length];
      for(int i=0; i<top+1; i++) 
    	  {b[i] = s[i];
    	  s = b;}
}

public static int order(char c) {//연산자 우선 순위 비교
	switch(c) {
		case '(':
		case '{':
			return 0;
		case '+':
		case '-':
			return 1;
		case '*':
		case '/':
			return 2;
		default:
			return -1;
	}
}

public static int compare(char str1, char str2) {
	int num1 = order(str1); // 현재 stack top
	int num2 = order(str2); // 입력받은 값
	
	// 현재 우선순위가 더 높은 경우
    if (num1 > num2){
        return 1;
    }
    // 우선순위가 같은 경우
    else if (num1 == num2){
        return 0;
    }
    // 입력받은 str 우선순위가 더 높은 경우
    else {
        return -1;
    }
}

}

public class main {
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		Scanner sc = new Scanner(System.in);
		Stack<Character> stack = new Stack<Character>();
		StringBuilder sb = new StringBuilder(); //후위표기법을 통해 얻은 변수들 arr에 담음
		String str=sc.next();
		char c = ' ';
		
		//1.중위표기법 -> 후위표기법 변환
		for(int i=0;i<str.length();i++) { //stack 사이즈 동안
			c = str.charAt(i);
			//문자 (A, B, C ...)라면
			if(Character.isLetter(c)) {
				sb.append(c);
			}
			//아니라면
			//연산자 스택이 비어있을 경우 push
			else if (stack.isEmpty()) {
				stack.push(c);
			}
			//연산자 스택 비어있지 않은 경우 
			else { //왼쪽 괄호라면
				if(c=='('||c=='{') {
					stack.push(c);
					continue; //다음 문자로
				}
				//닫는 괄호가 나온 경우
				//스택에 저장된 모든 연산자를 반환
				else if (c==')'||c=='}') {
					Character check = ' ';
					while(true) {
						check = (char)stack.pop();
						if(check == '('|| check =='{') {
							break;
						}
						else {
						sb.append(check);
						}
						}
					continue;
				}
				//현재 연산자의 우선순위가 더 높은 경우
				//스택에 연산자 저장
				else if(stack.compare((char)stack.peek(),c)>0) {
					stack.push(c);
				}
				//현재 연산자의 우선순위가 더 낮거나 같은 경우
				//스택에 있는 우선순위가 높은 연산자를 빼서 표현
				else {
					while(!stack.isEmpty()) {
						if(stack.compare(stack.peek(), c)<=0) {
							sb.append(stack.pop());
						}
						else {
							break;
						}
					}
					stack.push(c);
				}
			}
	}
		  char check = ' ';
	        while(!stack.isEmpty()) {
	            check = (char) stack.pop();
	            if (check != '(') {
	                sb.append(check);
	            }
	        }
		System.out.println(sb.toString());
	
		
		//2. 중위표기법을 후위표기법으로 계산*/

	}
	
}

